## 03-1 컴포넌트를 표현하는 JSX

* JSX(JavaScript XML)
  * 자바스크립트에 XML 표현법을 확장한 문법
  * 파일 하나에 자바스크립트와 HTML을 동시에 작업

#### JSX 사용하기

* JSX는 HTML의 문법이 아닌 XML 마크업 규칙을 따름
  * <와 마침표시 />는 쌍을 이뤄야 함

#### JSX의 작동 원리 알아보기

* 선언형 화면
  * 개발자는 JSX만 작성하고 엔진이 자바스크립트로 해석되는 것

## 03-2 컴포넌트와 구성 요소

#### 컴포넌트의 개념

* 기존 웹 프레임워크는 MVC 패턴을 사용함
* 재활용성을 높이기 위해 컴포넌트가 등장

##### 간단한 컴포넌트 추가하고 화면으로 띄우기

* 소스 참조
* 컴포넌트 첫 글자는 대문자로 함

```javascript
import TodaysPlan from './03/TodaysPlan'

<TodaysPlan/>
```

* Import 문에서 확장자는 생략됨
* 웹펙 코드 검색 확장자 기능

#### 컴포넌트 구성 요소 미리 살펴보기

* 프로퍼티
  * 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터
* 상태
  * 컴포넌트의 상태를 저장하고 변경하는 데이터
* 컨택스트
  * 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달되는 데이터



## 03-3 컴포넌트에 데이터를 전달하는 프로퍼티

* 상위 컴포넌트가 하위 컴포넌트에 값을 전달하는데 사용됨
* 프로퍼티 값은 변경 될 수 없음

#### 프로퍼티 기초 알아보기

* 속성 형태로 전달됨
* 프로퍼티가 상위 컴포넌트에서 하위 컴포넌트로 전달됨
* 단방향으로 데이터가 흐른다

#### 프로퍼티의 다양한 사용 방법 알아보기

* 자바스크립트의 자료형을 모두사용 할 수 있음
* 리액트에서 제공하는 prop-types 이용
* 문자열 이외의 값은 따옴표 대신 중괄호 {}를 이용해 사용
* bool을 전달하기 위해 단순히 이름만 선언해도 전달 할 수 있음

```react
<ChildComponent boolValue /> //true 전달
<ChildComponent /> //false wjsekf
```

* 객체 프로퍼티를 정의하면 객체 목록을 한눈에 확인 할 수 있음
* isRequired를 이용해 필수값으로 지정 할 수 있음



## 03-4 컴포넌트 상태 관리하기

* State

#### state로 상태 관리하기

* 값을 저장하거나 변경 할 수 있는 객체
* 버튼을 클릭하거나 값을 입력하는 이벤트와 함께 사용됨
* State 사용시 주의사항
  * 생성자에서 초기화
  * State값 변경을 위해 setState() 함수를 반드시 이용
  * setSate 함수는 비동기. 코드 이후 연결된 함수의 실행이 완료된 시점에 화면 동기화
* state 값은 setState() 함수로 변경
  * State값을 직접 변경하면 안되는 이유는 render() 함수로 화면을 그리는 시점은 리엑트 엔진이 정하기 때문
  * State 값을 바꾸더라도 리액트 엔진이 render() 함수를 호출하지 않음
  * setState 함수를 호출하면 render 호출하여 화면에 변경된 내용 출력 가능
* setState() 함수의 인자로 함수를 전달하면 이전 state값을 읽을 수 있음
  * setState 함수의 인자로 함수를 전달하면 이전 state 값을 읽는 과정을 생략 할 수 있음

```react
//일반 함수 사용
handleData(data){
  this.setState(function(prevState){
    const newState = {
      loading: false,
      formData: data + prevState.formData,
    };
    return newState;
  })
}

//화살표 함수 사용
handleData(data){
  this.setState(prevState => ({
    loading: false,
    fromData: data + prevState.formData
  }))
}
```



#### 클래스 인스턴스 변수와 forceUpdate() 함수로 state 관리하기

* setState 사용하는 것이 아닌, forceUpdate() 이용한 화면 강제 출력 가능
* State 로 관리하는것이 아니고, 로컬변수로 관리되고, forceupdate하는 방식
* 매번 새롭게 화면을 출력해야 하는 경우가 아니라면 가급적 지양되는 방식임



## 03-5 컴포넌트의 생명 주기

* 컴포넌트의 생성부터 소멸까지의 과정

#### 생명주기 함수 살펴보기

* 생명주기 함수는 render() 포함 8종류가 있음
* 리액트 엔진에서자동으로 호출함. 개발자가 마음대로 호출 할 수 없음.

#### constructor

* 맨 처음 생성될때 단 한번 호출
* super() 함수를 가장 위에 호출해야 함. 
  * 프로퍼티와 생명 주기 상태 등을 초기화하는 내용이 super 함수에 있음

#### render

* 데이터가 변경되어 새 화면을 그려야 할 때 자동으로 호출
* jsx의 반환 내용을 화면에 보여줌

#### static getDerivedStateFromProps(props, state)

* 정적함수
* 값에 접근하기 위해 인자로 전달 된 props, state 값을 참조
* props는 상위 컴포넌트에서 전달된 값
* state는 현재 컴포넌트의 state 값

#### componentDidMount()

* render이후 호출되는 함수
* 컴포넌트가 화면에 모두 표현된 이후 해야 하는 작업이있으면 여기서 진행됨

#### shouldComponentUpdate(nextProps, nextState)

* 프로퍼티 변경하거나, setState함수로 state 변경하면 화면이 새로 출력될지 판단하는 함수.
* 화면을 새로 출력할지 판단하기 떄문에 성능에 영향이 많이 감
* forceUpdate 사용시 이 함수는 사용되지 않음

#### getSnapshotBeforeUpdate(prevProps, prevState)

* 컴포넌트의 편경내용이 가상 화면에 반영 된 후 호출됨
* 실제로 화면에 출력되기 전에 호출됨. 실제 DOM 정보에 접근할 떄 사용됨

#### componentDidUpdate(prevProps, prevState, snpashot)

* 컴포넌트가 실제 화면에 출력된 후 호출됨
* 이전 프로퍼티, 이전 state rkqt, getSnapshotBeforeUpdate 함수에서 반환된 값을 인자로 받음
* 스크롤 위치를 옮기거나, 커서를 이동하는 등 DOM 정보를 변경할 때 사용할 수 있음

#### componenetWillUnmount()

* 컴포넌트가 소멸되며 호출되는 함수



## 03-6 클래스형 컴포넌트

* 클래스형 컴포넌트는 Compoenent, PureComponent 두 종류가 있음

####  Component 알아보기

* 프로퍼티, 스테이드, 생명주기가 들어있는 구조의 컴포넌트
* 앞서 계속 사용한 종류의 컴포넌트

#### PureComponent 

* Compoenent 클래스를 상속받은 클래스
* shouldComponentUpdate() 함수를 통해 얕은비교를 통해 데이터가 변경된 경우 render 실행
  * Component는 항상 render 실행

```javascript
import React from 'react';
import shallowEqual from 'shallow-equal';

export class Purecompoenent extends React.Component{
  shouldCompoenentUpdate(nextProps, nextState){
    return !shallowEqual(this.props, nextProps)||//현재 prop과 다음 prop 이 다른 경우 이거나
           !shallowEqual(this.state, nextState)//현재 state와 다음 state 가 다른 경우에 true 반환
	}
}
```



* 얕은비교 확인하기.
* shallowEqual 를 통해 데이터 변경이 있으면 화면을 재출력, 그렇지 않으면 진행
* 아래 얕은비교를 보면, 내용(또는 내용의 주소) 가 같은경우 true 반환

```javascript
import shallowEqual from 'shallow-equal';

const obj = {name: 'jack'};
const myList = [1,2,3,object];
const list1 = [1,2,3,object];
const list2 = [1,2,3,{name: 'jack'}];

mylist === list1 // false 서로 다른 선언
shallowEqual(myList, list1) //true 서로 같음
shallowEqual(list1, list2) //false. 객체가 서로 다름
```

* PureCompoenent와 불변변수로 성능 높이기

## 03-7 함수형 컴포넌트

